[
  {
    "id": "preload-angular-translate-partial-loader",
    "title": "Pre-loading partial loader translations",
    "intro": "Finding the balance between eager loading and lazy loading translation tables",
    "cover": "cover_wide.jpg",
    "date": "2015-04-09T14:20:16.125Z",
    "author": {
      "name": "Sander Sink",
      "gplus": "https://plus.google.com/+sander_sink_ozooner?rel=author",
      "photo": "src/assets/img/team/fadeit_team_sander_sink.jpg",
      "job_title": "Software engineer"
    },
    "content": [
      {
        "type": "h",
        "number": 2,
        "text": "Introduction"
      },
      {
        "type": "p",
        "text": "<a href=\"https://angular-translate.github.io/\">Angular-translate</a> is the de-facto internationalisation module for AngularJS applications. Basically it works by replacing translation keys from the translation dictionary. The problem is that larger applications have a lot of content, thus a lot of translations so it doesn't make sense to send the entire translations file to the client on initial page load. The good news is that there is a solution - <a href=\"https://github.com/angular-translate/angular-translate/blob/master/src/service/loader-partial.js\">partial loader</a>. It works as advertised - we can define translation files that are required to load for that page, thus lowering the amount of data required to transfer. The downside to partial loading is that first browser must initialize angular, which in turn will start loading the translation partials. The issue becomes apparent on slower connections where translation keys are either shown or invisible until partial loader finishes fetching the files. It can be a factor when trying to make a first impression. What if we could pre-load some parts that are common throughout our application? It would help improve the user experience on most pages, but will not eliminate the use of partial translations.<br/>Behind the scenes the partial loader uses angular's <em>$http</em> service to fetch a JSON file and store it in an array. Fortunately for us, angular has a built-in caching mechanism for <em>$http</em> service that we could leverage for our purpose. We are going to store the parts we want to pre-load in the $http cache, so when partial loader tries to fetch the files, it will hit the cache.<br/>By default the caching mechanism for <em>$http</em> service is using <em>$cacheFactory</em>'s cache with <em>'$http'</em> key, although caching mechanism can be overridden. Cache key is the request URL and value is an array containing 4 items:"
      },
      {
        "type": "list",
        "items": {
          "0": "response status - 200 for success",
          "1": "data - JSON for our needs",
          "2": "response headers - we leave it blank",
          "3": "status text - 'OK' for fulfilled request"
        }
      },
      {
        "type": "p",
        "text": "Assuming the translation file we want to pre-load is available at http://example.com/assets/translations/da-dk/common.json, let's test out the concept by creating a function that fakes cache entry for us:"
      },
      {
        "type": "code",
        "language": "javascript",
        "file": "cachefactory.txt"
      },
      {
        "type": "p",
        "text": "It works, however we have translation keys in code. Now we need to come up with a way to ship the desired JSON files at initial application load. An approach would be to keep translations in a .js file instead (an angular service, returning JSON string on call), however that would require us to migrate existing JSON files into Javascript objects and reduce translation maintainability. But wait, there is a Grunt plugin that already stores HTML templates in a similar way (<a href=\"https://github.com/karlgoldstein/grunt-html2js\">html2js</a>). The only difference is that the plugin uses <em>$templateCache</em> instead. Since <em>html2js</em> is part of our build process already, what we can do is pass the JSON translations to the angular app using the existing Grunt build task. Once angular is bootstrapped, we'll load translations from <em>$templateCache</em> and store them into the <em>$cacheFactory</em> cache as well. Here's how the Grunt task for storing .json files in <em>$templateCache</em> looks like:"
      },
      {
        "type": "code",
        "language": "javascript",
        "file": "html2js.txt"
      },
      {
        "type": "p",
        "text": "Let's now 'teach' the <em>putHttpCache</em> method to take translations from <em>$templateCache</em>:"
      },
      {
        "type": "code",
        "language": "javascript",
        "file": "cachefactory2.txt"
      },
      {
        "type": "h",
        "number": 2,
        "text": "Conclusion"
      },
      {
        "type": "p",
        "text": "Now we can take the best of both worlds - preload most frequently used translations and lazy-load translations for less visited pages. Our html2js build process works in similar manner - all templates ending with *.tpl2js.html are stored in <em>$templateCache</em>, whereas templates ending with *.tpl.html are only fetched on demand."
      }
    ]
  }
]
