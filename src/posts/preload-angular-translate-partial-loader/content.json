[
  {
    "id": "preload-angular-translate-partial-loader",
    "title": "Pre-loading partial loader translations",
    "intro": "Finding the balance between eager loading and lazy loading translation tables",
    "cover": "cover_wide.jpg",
    "date": "2015-04-09T14:20:16.125Z",
    "author": {
      "name": "Sander Sink",
      "gplus": "https://plus.google.com/+sander_sink_ozooner?rel=author",
      "photo": "src/assets/img/team/fadeit_team_sander_sink.jpg",
      "job_title": "Software engineer"
    },
    "content": [
      {
        "type": "h",
        "number": 2,
        "text": "Introduction"
      },
      {
        "type": "p",
        "text": "<a href=\"https://angular-translate.github.io/\">Angular-translate</a> is the de-facto internationalisation module for AngularJS applications. At a basic level, it works by replacing translation keys from the translation dictionary. However, in bigger applications the dictionary can become quite large, so it doesn't make sense to send the entire translations file to the client on initial page load. One solution is to do the heavy lifting with the partial loader. It works as advertised - we can define translation files that are required to load for that page, thus lowering the amount of data required to transfer. The downside to partial loading is that on initial page load the browser must first initialize angular, which in turn will start loading the translation partials. On slower connections the issue becomes apparent: the keys are displayed for a few seconds before they are translated. This can affect the user experience and will be negatively perceived by users (aka. the page looks broken). What if we could pre-load some parts that are common throughout our application? This will help improve the user experience on most pages, but will not eliminate the use of partial translations.<br/>Behind the scenes the partial loader uses angular's <em>$http</em> service to fetch a JSON file and store it in an array. Fortunately for us, angular has a built-in caching mechanism for <em>$http</em> service that we could leverage for our purpose. We are going to store the parts we want to pre-load in the $http cache, so when partial loader tries to fetch the files, it will hit the cache.<br/>The caching mechanism for <em>$http</em> service can be overridden, but by default it's using <em>$cacheFactory</em>'s cache with <em>'$http'</em>. Cache key is the request URL and value is an array containing 4 items:<ol><li>response status - 200 for success</li><li>data - JSON for our needs</li><li>response headers - we leave it blank</li><li>status text - 'OK' for fulfilled request</li></ol>Assuming the translation file we want to pre-load is available at http://example.com/assets/translations/da-dk/common.json, let's test out the concept by creating a function that fakes cache entry for us:"
      },
      {
        "type": "code",
        "language": "javascript",
        "file": "cachefactory.txt"
      },
      {
        "type": "p",
        "text": "It works, however we have translation keys in code. Now we need to come up with a way to ship the desired JSON files at initial application load. An approach would be to keep translations in a .js file instead (a angular service, returning JSON string on call). However, that would require us to migrate the JSON files we want to pre-load into Javascript objects, which sounds like a hack. But wait, a Grunt plugin already stores HTML templates in a similar way (<a href=\"https://github.com/karlgoldstein/grunt-html2js\">html2js</a>). The only difference is that the plugin uses <em>$templateCache</em> instead. Since <em>html2js</em> was part of our application, what we can do is pass the JSON translations to the angular app using the existing Grunt build task. Once angular is bootstrapped, we'll load translations from <em>$templateCache</em> and store them into the <em>$http</em> cache as well. Here's how the Grunt task for storing .json files in <em>$templateCache</em> looks like:"
      },
      {
        "type": "code",
        "language": "javascript",
        "file": "html2js.txt"
      },
      {
        "type": "p",
        "text": "Let's now 'teach' the <em>putHttpCache</em> method to take translations from <em>$templateCache</em>:"
      },
      {
        "type": "code",
        "language": "javascript",
        "file": "cachefactory2.txt"
      },
      {
        "type": "h",
        "number": 2,
        "text": "Conclusion"
      },
      {
        "type": "p",
        "text": "Now we can take the best of both worlds - preload most frequently used translations and lazy-load translations for less visited pages. Our html2js build process works in similar manner - all templates ending with *.tpl2js.html are stored in <em>$templateCache</em>, whereas templates ending with *.tpl.html are only fetched on demand."
      }
    ]
  }
]