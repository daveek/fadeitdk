[
  {
    "id": "getting-started-with-vuejs-angularjs-perspective",
    "title": "Getting started with Vue.js: AngularJS perspective",
    "intro": "See how it is to write applications with Vue.js: a library for building web interfaces that provides data-reactive components with a simple and flexible API.",
    "cover": "vuejs-angularjs-getting-started.jpg",
    "date": "2015-05-14T13:14:03.000Z",
    "author": {
      "name": "Dan Mindru",
      "gplus": "https://plus.google.com/+MindruDan?rel=author",
      "photo": "src/assets/img/team/fadeit_team_dan_mindru.jpg",
      "job_title": "Experience designer"
    },
    "content": [
      {
        "type": "h",
        "text": "Background"
      },
      {
        "type": "p",
        "text": "I jumped on the AngularJS train more than 1 year ago and had lots of fun working with it. From August to January 2015 I had the chance to research Angular application structures. The study was in relation to performance, but it touched on many other subjects, such as component reusability and learnability. <br/> I am new to Vue.js, therefore this article will illustrate my first encounter with the framework. Later on I will try to make a more comprehensive analysis, but I found the first stages of working with it very interesting."
      },
      {
        "type": "h",
        "text": "Vue.js and AngularJS"
      },
      {
        "type": "p",
        "text": "I felt comfortable with it just after a few days. It might be because it resembles other frameworks. It might be because of it’s simplicity, I couldn’t tell. To better portray the similarities, here’s a comparison of some of the high-level concepts in Angular and Vue."
      },
      {
        "type": "fake-table",
        "header": {
          "0": {
            "size": "8",
            "text": "AngularJS"
          },
          "1": {
            "size": "8",
            "text": "Vue.js"
          },
          "2": {
            "size": "8",
            "text": "Notes"
          }
        },
        "rows": {
          "0": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Angular Modules"
                  },
                  "1": {
                    "type": "code",
                    "language": "javascript",
                    "file": "table-module.js.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Components (module equivalent in Vue)"
                  },
                  "1": {
                    "type": "code",
                    "language": "javascript",
                    "file": "table-module-vue.js.txt"
                  }
                }
              },
              "2": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Notes"
                  },
                  "1": {
                    "type": "p",
                    "text": "Modules are a wrapper in Angular, but they hold most component logic in Vue. <br/><br/>You can see how much thought was put into Vue by looking at the component options: there’s a ‘name’ property that customises the component name (will be displayed in the  console, great help for debug)"
                  }
                }
              }
            }
          },
          "1": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Directives"
                  },
                  "1": {
                    "type": "code",
                    "language": "javascript",
                    "file": "table-directive.js.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Directives"
                  },
                  "1": {
                    "type": "code",
                    "language": "javascript",
                    "file": "table-directive-vue.js.txt"
                  }
                }
              },
              "2": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Notes"
                  },
                  "1": {
                    "type": "p",
                    "text": "Directives are simple in Vue; they seem to be more focused. In Angular a directive can be many things, perhaps being more similar to a ‘Component’ in Vue."
                  }
                }
              }
            }
          },
          "2": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Filters"
                  },
                  "1": {
                    "type": "code",
                    "language": "javascript",
                    "file": "table-filter.js.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Filters"
                  },
                  "1": {
                    "type": "code",
                    "language": "javascript",
                    "file": "table-filter-vue.js.txt"
                  }
                }
              },
              "2": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Notes"
                  },
                  "1": {
                    "type": "p",
                    "text": "Filters aren’t much different, although Vue offers more flexibility by providing a read/write option. (see <a href='http://vuejs.org/guide/custom-filter.html' target='_blank'>this guide</a>)"
                  }
                }
              }
            }
          }
        }
      },
      {
        "type": "p",
        "text": "Because Vue only wants to deal with the VM, it won’t tackle some of the challenges that Angular covers out of the box. Services / HTTP reqs, routing, promises (just to name a few) are not Vue’s concerns. That’s good and bad. Perhaps bad is not a good way to describe it, but it’s a negative aspect for someone that got used (and somewhat lazy) to Angular. In other words, we have to mix and match libraries as we go to cover our needs. Some developers would love this, others will think it’s a waste of time. However, once you find a few good libraries, you won’t have to do it again. On the flip side, you will have a lot of flexibility and only include what you need, when you need it. Imagine building your own smaller, focused framework based on a good foundation, Vue. <br/><br/>Building a personalized front-end stack is great fun too. The first stack we ended up with was made out of: Director (routing), Reqwest (you guessed it), Q (promises) and of course Vue. The best name I can make out of these is QRVD (kinda sounds like curved). For the rest of the article think of this stack in the background, although it won’t change much if you don’t. Have it mind every now and then. "
      },
      {
        "type": "h",
        "text": "Templating"
      },
      {
        "type": "p",
        "text": "For the same reasons that’s easy to write templates in Angular, it’s really easy to write them in Vue. In fact, it’s a bit of a struggle to find differences between the two. <br/><br/>Here’s an overview:"
      },
      {
        "type": "fake-table",
        "header": {
          "0": {
            "size": "8",
            "text": "AngularJS"
          },
          "1": {
            "size": "8",
            "text": "Vue.js"
          },
          "2": {
            "size": "8",
            "text": "Notes"
          }
        },
        "rows": {
          "0": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Interpolation"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-interpolations.html.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Interpolation"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-vue-interpolations.html.txt"
                  }
                }
              },
              "2": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Notes"
                  },
                  "1": {
                    "type": "p",
                    "text": "Unfortunately, if we try to output and object or array, Vue won’t be able to render it (we’ll see <em>[Object]</em>). I always found that useful in Angular."
                  }
                }
              }
            }
          },
          "1": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Model binding"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-model-binding.html.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Model binding"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-vue-model-binding.html.txt"
                  }
                }
              }
            }
          },
          "2": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Loops"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-loops.html.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Loops"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-vue-loops.html.txt"
                  }
                }
              },
              "2": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Notes"
                  },
                  "1": {
                    "type": "p",
                    "text": "Both support model options (ex. debounce for a loop filter). Vue also works if we want to assign repeated objects to a variable: <br/><br/> <em>v-repeat='item: items'</em>"
                  }
                }
              }
            }
          },
          "3": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Conditionals"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-conditionals.html.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Conditionals"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-vue-conditionals.html.txt"
                  }
                }
              }
            }
          },
          "4": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Conditional classes"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-conditional-classes.html.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Conditional classes"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-vue-conditional-classes.html.txt"
                  }
                }
              },
              "2": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Notes"
                  },
                  "1": {
                    "type": "p",
                    "text": "Another example that shows similarities. Both also support <em>v-attr/ng-attr</em>."
                  }
                }
              }
            }
          },
          "5": {
            "columns": {
              "0": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Event binding"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-dom-events.html.txt"
                  }
                }
              },
              "1": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Event binding"
                  },
                  "1": {
                    "type": "code",
                    "language": "markup",
                    "file": "table2-vue-dom-events.html.txt"
                  }
                }
              },
              "2": {
                "size": "8",
                "content": {
                  "0": {
                    "type": "title",
                    "text": "Notes"
                  },
                  "1": {
                    "type": "p",
                    "text": "My take is that the generic v-on directive makes things more consistent, but it might be a personal preference."
                  }
                }
              }
            }
          }
        }
      },
      {
        "type": "p",
        "text": "The list goes on, but it’s enough to get an idea. There’s even a v-cloak directive that hides the bindings before they are rendered (as ng-cloak does). <br/> However, there’s one directive that you won’t find in Angular: <em>v-with</em>. Attaching this directive and passing a data object will allow a child VM to inherit data from his parent. I feel it’s a drastically simplified Angular Controller, managing the data flow across the application. By default, components will have an isolated scope. That makes this directive essential, although components also accept <em>inherit</em> as a property (see <a target='_blank' href='http://vuejs.org/guide/components.html#Scope_Inheritance'>more on scope inheritance</a>)."
      },
      {
        "type": "h",
        "text": "Modularity / Application structures"
      },
      {
        "type": "p",
        "text": "As I mentioned, I researched this area in Angular. My conclusion was that Angular both nailed it and it didn’t. You can create great modular architectures that are indeed maintainable, reusable, comprehensible, etc. However, you’ll need a monster-build strategy to go with it, or perhaps use some tools like Require.js or Browserify to ease the pain. On top of that, if you are just starting with Angular you won’t probably come across a good structuring guide, which is a shame. It’s only later (or maybe too late) that Angular developers look into it.<br/><br/> <small>(I had the pleasure to talk with Matias Niemelä about this issue. For him structuring applications was no mystery. I was intrigued by the discussion, because there are many developers struggling with it, trying to get it right and avoiding major refactorings late in the process. Of course Matias deals with different issues in Angular, but my overall impression was that the Angular community doesn’t consider app architectures to be as important as they should be. As the framework becomes mature, it looks more and more developers become interested in modularity.)</small> <br/><br/> So how does Vue.js perform in this regard? Exactly the same. I believe developers are able to produce kickass modular architectures with it, but there’s no comprehensive guide on how to do it. There are bits and pieces here and there, but I wasn’t satisfied. In ‘Building larger applications’ you can see an example of what a modular structure could be in Vue."
      },
      {
        "type": "h",
        "number": 3,
        "text": "Components"
      },
      {
        "type": "p",
        "text": "Before that, I have to add a few details on components. I think Vue managed to clearly separate components, which we can’t really say about Angular. It’s perhaps closer to Angular 2, which is great news in my mind. It means Vue is one step ahead. <br/> Vue also makes Angular’s <em>$scope</em> look bad. As the Angular team found themselves, it shouldn’t be there (the same with controllers)."
      },
      {
        "type": "h",
        "number": 3,
        "text": "Scopes / Data flow"
      },
      {
        "type": "p",
        "text": "I truly believe Vue is elegant when it comes to Data flow & control. It feels natural and eliminates the use of emit/broadcasting mechanism to communicate with parents (although Vue provides such events). There’s a downside - the components and views become even more coupled, but there are ways to work with it and still have reusable components. Services are one way to do it, but there’s not much about them in the docs."
      },
      {
        "type": "h",
        "number": 3,
        "text": "Services"
      },
      {
        "type": "p",
        "text": "One approach for writing services is to use a <em>HTTP</em> -> <em>Service</em> -> <em>Component</em> mechanism. Because the source is written in Coffee, I’ll provide examples in both CoffeeScript and Vanilla JS. HTTP has to be generic, so we can extend it for each object:"
      },
      {
        "type": "fake-table",
        "largeCode": true,
        "header": {
          "0": {
            "size": "12",
            "text": "CoffeeScript"
          },
          "1": {
            "size": "12",
            "text": "JavaScript"
          }
        },
        "rows": {
          "0": {
            "columns": {
              "0": {
                "size": "12",
                "content": {
                  "0": {
                    "type": "code",
                    "language": "coffeescript",
                    "file": "structure1.coffee.txt"
                  }
                }
              },
              "1": {
                "size": "12",
                "content": {
                  "0": {
                    "type": "code",
                    "language": "javascript",
                    "file": "structure1.js.txt"
                  }
                }
              }
            }
          }
        }
      },
      {
        "type": "p",
        "text": "Just for reference, a patch request using reqwest looks like this:"
      },
      {
        "type": "code",
        "language": "javascript",
        "file": "patch-example.js.txt"
      },
      {
        "type": "p",
        "text": "In CoffeeScript we can extend the HTTP class to adapt it for other use cases. For example, the User object could look like: <br/> (Note: Angular already has the $http service, which eliminates the need of a HTTP object)"
      },
      {
        "type": "fake-table",
        "largeCode": true,
        "header": {
          "0": {
            "size": "12",
            "text": "CoffeeScript"
          },
          "1": {
            "size": "12",
            "text": "JavaScript"
          }
        },
        "rows": {
          "0": {
            "columns": {
              "0": {
                "size": "12",
                "content": {
                  "0": {
                    "type": "code",
                    "language": "coffeescript",
                    "file": "user-http.coffee.txt"
                  }
                }
              },
              "1": {
                "size": "12",
                "content": {
                  "0": {
                    "type": "code",
                    "language": "javascript",
                    "file": "user-http.js.txt"
                  }
                }
              }
            }
          }
        }
      },
      {
        "type": "p",
        "text": "Then come services, which are perhaps closer to what we’re used to in Angular. For the same Object, we need to pass UserHTTP as a constructor parameter and then we’ll be able to call methods its methods and process the data as needed (before or after request are sent)."
      },
      {
        "type": "fake-table",
        "largeCode": true,
        "header": {
          "0": {
            "size": "12",
            "text": "CoffeeScript"
          },
          "1": {
            "size": "12",
            "text": "JavaScript"
          }
        },
        "rows": {
          "0": {
            "columns": {
              "0": {
                "size": "12",
                "content": {
                  "0": {
                    "type": "code",
                    "language": "coffeescript",
                    "file": "user-service.coffee.txt"
                  }
                }
              },
              "1": {
                "size": "12",
                "content": {
                  "0": {
                    "type": "code",
                    "language": "javascript",
                    "file": "user-service.js.txt"
                  }
                }
              }
            }
          }
        }
      },
      {
        "type": "p",
        "text": "Finally, in any component we can instantiate a service and call the methods that in turn will make a HTTP request."
      },
      {
        "type": "code",
        "language": "javascript",
        "file": "service-call-ex.js.txt"
      },
      {
        "type": "p",
        "text": "In the next section of the article I will try to illustrate a higher level diagram of how this all works."
      },
      {
        "type": "h",
        "text": "Building larger applications"
      },
      {
        "type": "p",
        "text": "First of all, what is a large app? Well, potentially any app can become large. When it’s hard to understand how things are working and the structure is not comprehensible for outsiders, then you’re probably dealing with a large app. <br/> After about a week of working on a Vue application the code looked very messy. It’s hard to tell where something begins and where it ends. That’s because it wasn’t properly separated, but this doesn’t have anything to do with Vue. It has to do everything to do with my decisions. As a result, the only choice I have now is to take a step back, analyze and refactor. <br/><br/> Before looking at the diagram, it is worth mentioning that Browserify was used to split things up. As I wrote before, you can either follow this approach or create a build strategy with Gulp/Grunt that concatenates the files (in the right order of course). This is not a particularly large app, but it has potential to grow into one.<br/><br/> Get a full copy of the diagram <a href='/posts/getting-started-with-vuejs-angularjs-perspective/vue-large-app-structure-diagram.svg' target='_blank'>here</a>."
      },
      {
        "type": "img",
        "url": "posts/getting-started-with-vuejs-angularjs-perspective/vue-large-app-structure-diagram.svg",
        "caption": "Diagram: one way to structure larger Vue.js apps."
      },
      {
        "type": "p",
        "text": "In terms of file/directory structure, here’s how it would look:<br/> (get a full copy <a href='/posts/getting-started-with-vuejs-angularjs-perspective/vue-large-app-directory-structure.svg' target='_blank'>here</a>)"
      },
      {
        "type": "img",
        "url": "posts/getting-started-with-vuejs-angularjs-perspective/vue-large-app-directory-structure.svg",
        "caption": "Possible directory structure for a larger Vue.js app."
      },
      {
        "type": "h",
        "text": "Final words"
      },
      {
        "type": "p",
        "text": "I hope these sketches will be a good starting point/source of inspiration for those starting out with Vue. <br/> In future posts I’ll probably write about testing, maintainability or scalability, if I’ll discover something interesting. <br/> My final words are: try out Vue, you might find it useful for many of your projects. It’s a nice little library with as many super powers as Angular!"
      }
    ]
  }
]
