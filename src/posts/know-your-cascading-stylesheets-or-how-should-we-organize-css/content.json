[
  {
    "id": "know-your-cascading-stylesheets-or-how-should-we-organize-css",
    "title": "Know your cascading stylesheets OR how should we organize CSS?",
    "intro": "How can we create maintainable, reusable, comprehensible CSS? Is there a formula that works for everybody, or is it just a matter of personal preference?",
    "cover": "cover.jpg",
    "date": "2015-04-16T12:10:00.000Z",
    "author": {
      "name": "Dan Mindru",
      "gplus": "https://plus.google.com/+MindruDan?rel=author",
      "photo": "src/assets/img/team/fadeit_team_dan_mindru.jpg",
      "job_title": "Experience designer"
    },
    "content": [
      {
        "type": "p",
        "text": "Here’s my experience: every time I start a new project I feel like re-thinking my CSS strategy. The reason? I never felt satisfied with the quality of the stylesheets at the end of a project.<br/> The main reason is that there are to types of CSS: the original pretty CSS and 'after a few months' CSS. Most of us start out ambitious, carefully writing properties and actually documenting the process. As it happens, when fixes or features need to be added after a few weeks, we just throw properties wherever to get it done, because deadlines. "
      },
      {
        "type": "h",
        "text": "The problem with CSS"
      },
      {
        "type": "p",
        "text": "Documentation, formatting, frameworks, pre-processors, specificity - they all are trouble makers. Any of these might force you to give up and sell your soul. I am looking at you, the so called developer that appended `!important` to a property. In the W3C spec, ‘important’ is documented as ‘you gave up and now a scrambled mess of selectors that you we have no freaking idea what they do anymore took control of your stylesheet’.<br/>In all seriousness now, you should never have to write it. However, there are many other things that show you lost it. For example, if you have the same selector in many places and you are not sure what exactly you’re changing when updating a property.<br/><br/>I am not writing this article because I have it all figured it out, but because I have some ideas on how to improve our CSS. I don’t want it to look like a set of rules, but rather start a constructive dialog where I share my experience so far."
      },
      {
        "type": "h",
        "text": "The solutions today"
      },
      {
        "type": "h",
        "number": 3,
        "text": "Short on pre-processors"
      },
      {
        "type": "p",
        "text": "We need to get some things straight. I am using a CSS pre-processors (LESS, have been using SASS too) and I can’t go back. It makes my stylesheets more consistent and enables me to write less (duh) code. It also makes it easy to change global properties that (ironically) truly cascade on all elements. This article is not about pre-processors and their are most certainly NOT a solution to CSS organization issues. While they might be helpful, they can create problems of their on. I will touch the subject here and there, because many front-enders rely on them to keep their sanity."
      },
      {
        "type": "h",
        "number": 3,
        "text": "Properties"
      },
      {
        "type": "p",
        "text": "Let’s start with the easy part.<br/>When it comes to properties, what works and what doesn’t? <br/> I’ve been going the random way until now and that’s why I would want to try something else. Here are the most popular options:"
      },
      {
        "type": "list",
        "items": {
          "0": "Group by type",
          "1": "Order by line length",
          "2": "Alphabetise"
        }
      },
      {
        "type": "h",
        "number": 4,
        "text": "1. Group by type"
      },
      {
        "type": "p",
        "text": "This method was once (and maybe still is) the most popular method of writing properties. Nicolas Gallager’s <a href='https://github.com/necolas/idiomatic-css' target='_blank'>idiomatic CSS</a> recommends this style for smaller teams, but larger teams seem to be more comfortable with alphabetising.<br/>Here’s one how to do it:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "group-by-type.css.txt"
      },
      {
        "type": "p",
        "text": "Obviously you are free to add your own types, such as <em>Effects</em> (can be border-radius, box-shadow, etc), <em>Animations & Transitions</em> or <em>Transforms</em>. There aren’t really any rules, you can create your own as long as you are consistent. The downside is that the rest of the team has to learn your rules, which is not very efficient."
      },
      {
        "type": "h",
        "number": 4,
        "text": "2. Order by line length"
      },
      {
        "type": "p",
        "text": "This is the old school method, which some developers like because it decreases the amount of lines and gives them a better overview of the stylesheet. I don’t think this method is realistic today, especially when we have to pile up a bunch of duplicate properties to support all browsers.<br/>Here’s why it worked before:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "order-by-line-length1.css.txt"
      },
      {
        "type": "p",
        "text": "...and here is why it doesn’t work today:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "order-by-line-length2.css.txt"
      },
      {
        "type": "p",
        "text": "To be fair about it, I should point out that there is a solution. By using a task runner (such as <a href='http://gruntjs.com/' target='_blank'>Grunt</a> or <a href='http://gulpjs.com/' target='_blank'>Gulp</a>) to automatically prefix the properties that require a vendor prefix. This way we could remove much of the duplicate styles and get to:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "order-by-line-length3.css.txt"
      },
      {
        "type": "p",
        "text": "It’s better, but probably 1-2 properties away from being hard to read. Some developers used to argue that it also decreases the size of the CSS file, which is now a commodity. Again, by using a task runner we can eliminate all spaces and line breaks. This gives us the freedom of writing CSS however we like, with plenty of spaces and comments. (<a href='https://github.com/gruntjs/grunt-contrib-cssmin' target='_blank'>grunt-cssmin</a> and <a href='https://github.com/chilijung/gulp-cssmin' target='_blank'>gulp-cssmin</a>) <br/>I wonder if anybody is still following this approach today. I wouldn’t be surprised if it would become no more than a page in the history of web development in the near future.<br/><br/> By the way, what’s the deal with the autoprefixer? It’s a life saver. If you are not using one, head over to <a href='https://github.com/nDmitry/grunt-autoprefixer' target='_blank'>grunt autoprefixer</a> or <a href='https://github.com/sindresorhus/gulp-autoprefixer' target='_blank'>gulp autoprefixer</a> and expect to get your mind blown. You’ll drastically reduce the size of your CSS source and increase it's readability. If you are using a pre-processors you will also get rid of a huge chunk of mixins."
      },
      {
        "type": "h",
        "number": 4,
        "text": "3. Alphabetise"
      },
      {
        "type": "p",
        "text": "The last but not the least method is alphabetising properties. Many developers like the consistency that it brings, that’s why it works well for bigger teams. Any other method you might choose can vary depending on the developer’s mindset, but this one always stays the same. It’s efficient and also brings some of the advantages we gain from grouping by type. However, CSS properties have a strong relationship - for example absolute positioning with z-index, left or top. It’s hard to visualise these relationships when alphabetising.<br/>There’s more criticism: we certainly don’t write CSS alphabetically, therefore developers have to invest extra time to alphabetise declarations after they wrote them. What about for those using a pre-processor, how will we alphabetise mixins?<br/><br/> Should we actually follow any rules while writing properties? In all honesty, I never felt the need to add rules, random works just fine for me. At the same time, I haven’t worked in a large team of front-enders. Maybe there is a point to alphabetise, but it certainly doesn’t feel wrong to randomly write the properties for me."
      },
      {
        "type": "h",
        "number": 3,
        "text": "Shorthand"
      },
      {
        "type": "p",
        "text": "To wrap up the properties, here’s another interesting topic. Should we use shorthand or write it all down? My opinion is: it depends. If you are talking about box model properties, it sometimes makes sense to use shorthand. I use it in the following circumstances:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "shorthand1.css.txt"
      },
      {
        "type": "p",
        "text": "The shorthand can force values to top, right, bottom and left. This can result in all kinds of conflicts, for example:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "shorthand2.css.txt"
      },
      {
        "type": "p",
        "text": "In this case, I actually want to maintain the original margin-top, but the shorthand forces me to either repeat the declaration or even worse - set it to a different value without realizing. In this case I prefer not to use shorthand:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "shorthand3.css.txt"
      },
      {
        "type": "p",
        "text": "For other properties is makes sense to generally use shorthand, like border-radius. There is no simple answer to ‘should I use shorthand’. My take is to think about each property and decide on the spot. I might start with shorthand and change it later when I notice redundant declarations."
      },
      {
        "type": "h",
        "number": 3,
        "text": "Splitting CSS info files"
      },
      {
        "type": "p",
        "text": "This is were the ‘pro’ territory starts. It’s not because it’s hard to do (it used to be harder), but you have to know what you’re doing. You need to have a clear idea of what CSS you’ll write and how it’s going to be connected. Call if ‘CSS architecture’ if you will. <br/>One of the common ways to get started is to use the SMACSS principles. The idea is to split the rules into 5 categories:"
      },
      {
        "type": "list",
        "items": {
          "0": "Base",
          "1": "Layout",
          "2": "Module",
          "3": "State",
          "4": "Theme"
        }
      },
      {
        "type": "p",
        "text": "Of course, there’s more to SMACSS than this - but I won’t get into details. This approach will introduce modularity to CSS (to some extent), which of course is what every developer dreams of. It’s the holy grail: flexibility, maintainability, extensibility, comprehensibility - it has it all. Sounds good, let’s all do it! Only… I don’t think it really works with CSS. It can work sure, but do you know any CSS architects which can design a modular stylesheet system? I believe that most modular systems work well because of the pre-analysis and thorough planning initially invested into them. Maybe we could do the same with CSS… but how? <br/><br/>I’ll leave this one open, but I have to add one more thing. This kind of structure has never worked for me. My team members weren’t either. It’s hard to find declarations and most importantly: it doesn’t align with the cascade. If you don’t believe me, fork Bootstrap and try to modify or extend it. You’ll be able to do it sure, but how much time did you spend pinpointing those declarations?"
      },
      {
        "type": "h",
        "number": 3,
        "text": "The cascade / specificity"
      },
      {
        "type": "p",
        "text": "Oh boy, this is a big one.<br/>Let’s get the basics right first and then you'll see why specificity can be a bitch.<br/> In a nutshell, CSS properties are applied based on the following model:<br/><br/> <em>inline style > ID > class / attributes / pseudo-class > element / pseudo-element</em> <br/><br/> Simply put, here’s how CSS specificity is calculated:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "specificity1.css.txt"
      },
      {
        "type": "p",
        "text": "By the way, if you understand this, you should never need to use important. Even if you completely mess up, you can still use tricks to avoid it, as shown in this example:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "specificity2.css.txt"
      },
      {
        "type": "p",
        "text": "Finally, let’s focus on two of the declarations above."
      },
      {
        "type": "code",
        "language": "css",
        "file": "specificity3.css.txt"
      },
      {
        "type": "p",
        "text": "In this case, the specificity is the same for both declarations. Therefore, the selectors that is last in the file wins (‘p span’). You can imagine how splitting CSS into many files can be problematic. <br/> That’s the least of the problems though. Specificity can single-handedly ruin CSS for us. It's a frequent problem with frameworks, content management systems, style guides and of course pre-processors. The real issue is that when CSS is specific, it forces us to continue writing more and more specific selectors. We then easily end up with redundant, complicated and disorganized stylesheets."
      },
      {
        "type": "quote",
        "text": "Rule number one while writing CSS: be specific only when truly necessary.",
        "ref": "http://mindrudan.com"
      },
      {
        "type": "h",
        "number": 3,
        "text": "Element tree indentation"
      },
      {
        "type": "p",
        "text": "Specificity used to be a common problem with pre-processor users. The advertisement for both SASS and LESS that got a lot of developers to use them was: 'reflect your HTML (or DOM) structure in your stylesheet'. <br/> Let's see what that means. For the follwing HTML: "
      },
      {
        "type": "code",
        "language": "markup",
        "file": "indentation1.html.txt"
      },
      {
        "type": "p",
        "text": "Instead of this CSS:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "indentation2.css.txt"
      },
      {
        "type": "p",
        "text": "We could write the following LESS/SASS code:"
      },
      {
        "type": "code",
        "language": "less",
        "file": "indentation3.less.txt"
      },
      {
        "type": "p",
        "text": "If that doesn’t impress you, it should. It helps us easier implement something called OOCSS - you guessed it - object oriented CSS. It’s not object oriented in a true sense, but it encourages the development of components that are independent, self-contained and highly reusable. (there’s also more to OOCSS, but I again won’t go into details)<br/> The downside of this is being specific all the time, which we should avoid. Be specific only when truly necessary, remember?<br/> There’s a way around this too."
      },
      {
        "type": "h",
        "number": 3,
        "text": "Block, element, modifier"
      },
      {
        "type": "p",
        "text": "BEM is a naming convention that makes css selectors more informative and adds a certain amount of strictness. The pattern it introduces is the following:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "bem1.css.txt"
      },
      {
        "type": "p",
        "text": "Specificity is not achieved by the naming conventions. What it lacks is the nesting of pre-processors, but nothing stops us from writing it like this:"
      },
      {
        "type": "code",
        "language": "css",
        "file": "bem2.css.txt"
      },
      {
        "type": "p",
        "text": "Keep in mind that there are several variations of BEM conventions, but the core concept is there in all of them. For some time now pre-processors introduced BEM support, which enables us to simulate the DOM structure and use proper nesting, without having specificity troubles. Both LESS and SASS support a form of the following:"
      },
      {
        "type": "code",
        "language": "less",
        "file": "bem3.less.txt"
      },
      {
        "type": "p",
        "text": "That’s neat. As long as we don’t mind the ‘ugly’ HTML that comes out of it, it’s a very reasonable solution. The ‘ugly’ problem is discussed in <a href='http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/' target='_blank'>this article</a> and I think the author has some good points. We shouldn’t be dismissing this concept just because it looks odd."
      },
      {
        "type": "h",
        "text": "My conclusion so far"
      },
      {
        "type": "p",
        "text": "There’s more to cover, but I feel it was too optimistic to do it all in 1 article. A particularly interesting subject are design style guides, which I plan to write about in a future post. Don’t forget: write meaningful names for your selectors and pay attention to your HTML structure, many CSS problems start there.<br/> What else do you use? Do you write a table of contents? Do you have global classes like ‘.hidden’ or ‘.disabled’? How do you organize media queries? What about tools like <a href='https://github.com/SlexAxton/css-colorguard' target='_blank'>colorguard</a>, <a href='https://github.com/Huddle/PhantomCSS' target='_blank'>PhantomCSS</a> or <a href='https://github.com/katiefenn/parker' target='_blank'>parker</a>, can they help us organize our CSS better? <br/>There’s more. Self contained components à la React or Polymer. Are they the future?<br/><br/> However, you scrolled this far to see a conclusion. My conclusion is: try out different methods until you and your team members are satisfied. There are many ways to organize stylesheets, but none of them are going to solve all our problems. Me? I can’t go back from LESS, autoprefixer, and cssmin. I try to write my stylesheets in a OOCSS-way, which sometimes works. Lastly, I think BEM is neat and will definitely push it more in my future projects."
      }
    ]
  }
]